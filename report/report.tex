% report.tex

\documentclass[a4paper,11pt]{article}
\usepackage{hyperref}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{varwidth}
\usepackage{tasks}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }

\usepackage{graphicx}

\usepackage{listings}

% Change enumerate environments you use letters
\renewcommand{\theenumi}{\alph{enumi}}

% Set title, author name and date
\title{Consensus}
\author{Johannes JÃ¸rgensen (jgjo),\\ Kevin Skovgaard Gravesen (kegr),\\ Joakim Andreasen (joaan)} 
\date{\today}

\begin{document} 

\maketitle

\subsection{Introduction}
This small GoLang program is a demo of active replication. A list of ports can be added to a .env file,
which the clients and server (nodes) can use to find their respective ports.

The demo assumes that no messages are lost, which would require some alteration to the code if this was the case.

\subsection{Architecture}
A description of the architecture of the system and its protocols (behaviour), including any protocols used internally between nodes of the system. 

Our implementation of the distributed auction system applies the active replication principle, which means that the installed servers do not have a primary, but rather they all have direct connection to the clients. 
Therefore to validate the responses given by the servers, we implemented a system that compares all responses from the servers and picks the respons that occurs the most. This is to make sure that no corrupt server can output an incorrect respons to trick the client.
Furthermore it ensures that one server can crash or be out of order, while the clients can still access the service, without any downtime. The communication between client and servers is being done throught the use of GRPC and protocol buffers (proto). 
this means that our service have 2 API's, one for bidding (bid) and one for getting the results of the auction (result). These API's makes use of proto-objects, that makes the communication between client and server easier by using serialized structured data.
In our implementation we have 4 proto-objects. One named Amount, which is designated for bidding on an auction with the bid-amount and a bidder (username). Another one named Outcome, which provides a boolean (isFinished) that describes wether the auction is over or not, a price (the highest bid) and a bidder (username). The last important proto-object is the Ack, which is just a boolean that ensures the bidded amount is acknowledged by the servers. The forth proto-object behaves like a return void statement, that doesn't return anything of importance to the system. This is done as GRPC does not support void statements.

\subsection{1st Correctness}
Argue whether your implementation satisfies linearisability or sequential consistency. In order to do so, first, you must state precisely what such property is.


If a system is linearizable it means that the systems needs to process operations according to their real-time invocation.
This includes the travel time of messages sent in the system. So if user farther away from a server sends a request,
that request has to be processed before a possible closer invocation.

This demo does not satisfy this requirement because of potential race conditions between the servers (nodes) and clients.
Ofcourse this demo runs locally on the same machine, which minimizes the risk for out of order handling of the requests.

But if the system were deployed globally, theses race conditions would become every more problematic.


A sequential consistant system does not need the real-time order, but the timeline of operations still needs to be the same on every client.

This is easier to deal with, and if the nodes in the demo locked a central database, then the system could be sqeuential consistant.
Altough that would mean that there is a single point of failure on the database that also would need to be accounted for.

\section{2nd. Correctness}
In the absence of failure, the implementation is designed in the way to ensure correctness of bidding and consistency of the right results. 
The implementation ensures correctness of bidding by making the auction house servers handle the bidding and that the bid is vaild. The implementation does not ensure safety of a condidtion race for two user that bid on the same time.
\\
\\
We ensure that our protocol is correct in presence of failure, with the use of active replication. 
If a server fails, client are then still able to interact with other active servers via. the multi-port setup in the `.env` file.
If a clients fails, the `sendBid()` method sends a clients bid to all servers. Even if some nodes fail, others can process the bid ensuring that the ongoing auction continues.
\\

\subsection*{Link to Github repository}

\href{https://github.com/ITU-DISYS2024-CENTRALIZEDSYSTEMS/distributed-auction-system}{https://github.com/ITU-DISYS2024-CENTRALIZEDSYSTEMS/distributed-auction-system}
\end{document}
