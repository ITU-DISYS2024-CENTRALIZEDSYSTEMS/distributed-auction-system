% report.tex

\documentclass[a4paper,11pt]{article}
\usepackage{hyperref}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{varwidth}
\usepackage{tasks}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
 }

\usepackage{graphicx}

\usepackage{listings}

% Change enumerate environments you use letters
\renewcommand{\theenumi}{\alph{enumi}}

% Set title, author name and date
\title{Consensus}
\author{Johannes Jørgensen (jgjo),\\ Kevin Skovgaard Gravesen (kegr),\\ Joakim Andreasen (joaan)} 
\date{\today}

\begin{document} 

\maketitle

\section{Introduction}
This small GoLang program is a demo of active replication. A list of ports can be added to a .env file,
which the clients and server (nodes) can use to find their respective ports.
\\
The demo assumes that no messages are lost, which would require some alteration to the code if this was the case.

\section{Architecture}
A description of the architecture of the system and its protocols (behavior), including any protocols used internally between nodes of the system.\\
Our implementation of the distributed auction system applies the active replication principle, which means that the installed servers do not have a primary server. Instead, they all maintain a direct connection to the clients.\\
To validate the responses given by the servers, we implemented a system that compares all responses from the servers and selects the response that occurs most frequently. This ensures that no corrupt server can provide an incorrect response to mislead the client.
Furthermore, it guarantees that a single server can crash or go offline while the clients can still access the service without any downtime. Communication between clients and servers is facilitated through gRPC and protocol buffers (proto).\\\\
This means that our service has two APIs: one for bidding ($bid$) and one for retrieving the auction results ($result$). These APIs use proto objects, which simplify communication between clients and servers by employing serialized structured data.
In our implementation, we have four proto objects. The first is Amount, which is used for placing a bid and includes the bid amount and the bidder’s username. The second is Outcome, which provides a boolean (isFinished) indicating whether the auction has ended, the highest bid (price), and the username of the highest bidder. The third important proto object is Ack, which is a boolean confirming that the bid amount has been acknowledged by the servers.
The fourth proto object acts like a return void statement, as it does not return any significant data to the system. This is necessary because gRPC does not support void statements.
\subsection{Correctness 1.}
Argue whether your implementation satisfies linearisability or sequential consistency. In order to do so, first, you must state precisely what such property is.


If a system is linearizable it means that the systems needs to process operations according to their real-time invocation.
This includes the travel time of messages sent in the system. So if user farther away from a server sends a request,
that request has to be processed before a possible closer invocation.

This demo does not satisfy this requirement because of potential race conditions between the servers (nodes) and clients.
Ofcourse this demo runs locally on the same machine, which minimizes the risk for out of order handling of the requests.

But if the system were deployed globally, theses race conditions would become every more problematic.


A sequential consistant system does not need the real-time order, but the timeline of operations still needs to be the same on every client.

This is easier to deal with, and if the nodes in the demo locked a central database, then the system could be sqeuential consistant.
Altough that would mean that there is a single point of failure on the database that also would need to be accounted for.

\section{2nd. Correctness}
In the absence of failure, the implementation is designed in the way to ensure correctness of bidding and consistency of the right results.
\\
We ensure that our protocol is correct in presence of failure, with the use of active replication. 
If a server fails, client are then still able to interact with other active servers via. the multi-port setup in the `.env` file.
If a clients fails, the `sendBid()` method sends a clients bid to all servers. Even if some nodes fail, others can process the bid ensuring that the ongoing auction continues.
\\
\\
The implementation ensures correctness of bidding by making the auction house servers handle the bidding and that the bid is vaild. The implementation does not ensure safety of a condidtion race for two user that bid on the same time.
\\
Client can independently query for the results of an open bid, at any time they want. The servers handle these requests and reliably returns the current auction outcome. Because of active replication, we ensure the state of the lates highest bid across of all servers.  
\\

\subsection*{Link to Github repository}

\href{https://github.com/ITU-DISYS2024-CENTRALIZEDSYSTEMS/distributed-auction-system}{https://github.com/ITU-DISYS2024-CENTRALIZEDSYSTEMS/distributed-auction-system}
\end{document}
